unit LightThd;

interface

uses
  System.Classes, IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient, IdGlobal,
  IdIOHandler, IdIOHandlerSocket, IdIOHandlerStack, system.SysUtils, System.Generics.Collections,
  Winapi.Windows, CodeSiteLogging;

type
  TLightThread = class(TThread)
  private
    { Private declarations }
    lightTcp: TIdTCPClient;
    lightValue, lightRequest: TIdBytes;
    pTime: Integer;
    exeFlag: Integer;
    exeQue: TQueue<Integer>;
    isSend: Boolean;

    procedure relay1On;
    procedure relay1Off;
    procedure relay2On;
    procedure relay2Off;
    procedure SendlightRequest;

  protected
    procedure Execute; override;

  public
    closeSignal: Integer;

    constructor Create(ip: string; port,playTime: Integer);
    destructor Destroy; override;

   procedure addQue(queVal: Integer);

  end;

implementation


{ TLightThd }

procedure TLightThread.addQue(queVal: Integer);
begin
  if isSend = False then begin
    if exeQue <> nil then begin
      exeQue.Enqueue(queVal);
      isSend := True;
    end;
  end;
end;

constructor TLightThread.Create(ip: string; port,playTime: Integer);
begin
  try
    isSend := False;
    closeSignal := False;
    FreeOnTerminate := True;
    inherited Create(False);
    Priority := tpIdle;

    exeQue := TQueue<Integer>.Create;
    SetLength(lightValue,10);
    SetLength(lightRequest,10);
    ZeroMemory(Pointer(lightValue),Length(lightValue) * SizeOf(Integer));
    ZeroMemory(Pointer(lightRequest),Length(lightRequest) * SizeOf(Integer));
    lightRequest[0] := $02;
    lightRequest[1] := $ff;
    lightRequest[2] := $00;
    lightRequest[3] := $01;
    lightRequest[4] := $52;
    lightRequest[5] := $00;
    lightRequest[6] := $00;
    lightRequest[7] := $00;
    lightRequest[8] := $ae;
    lightRequest[9] := $03;


    lightTcp := TIdTCPClient.Create(nil);
    lightTcp.Host := ip;
    lightTcp.Port := port;
    pTime := playTime;
    lightTcp.Connect;
  except on E: Exception do

  end;


end;

destructor TLightThread.Destroy;
begin
  //정상표시로 돌리고 종료 아마도 파란색
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $31;
  lightValue[7] := $30;
  lightValue[8] := $aa;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);

  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $32;
  lightValue[7] := $30;
  lightValue[8] := $a9;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);

  FreeAndNil(lightTcp);
end;

procedure TLightThread.Execute;
begin
  try
    while not Terminated do begin
      if closeSignal = 1 then begin
        Self.Suspended := True;
      end;

      if exeQue.Count > 0 then begin
        exeFlag := exeQue.Dequeue;
        if exeFlag = 1 then
          relay1On
        else if exeFlag = 2 then
          relay2On
        else if exeFlag = 9 then
          relay1Off
        else if exeFlag = 10 then
          relay2Off
      end;











      SendlightRequest;
      Sleep(500);
    end;
  except on E: Exception do
  end;
end;

procedure TLightThread.relay1Off;
begin
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $31;
  lightValue[7] := $30;
  lightValue[8] := $aa;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);
end;

procedure TLightThread.relay1On;
var
  PastCount: LongInt;
begin
  //릴레이1 ON
  exeFlag := 0;
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $31;
  lightValue[7] := $31;
  lightValue[8] := $ab;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);

end;

procedure TLightThread.relay2Off;
begin
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $32;
  lightValue[7] := $30;
  lightValue[8] := $a9;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);
end;

procedure TLightThread.relay2On;
var
  PastCount: LongInt;
begin
  //릴레이1 ON
  exeFlag := 0;
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightValue[0] := $02;
  lightValue[1] := $ff;
  lightValue[2] := $00;
  lightValue[3] := $01;
  lightValue[4] := $57;
  lightValue[5] := $00;
  lightValue[6] := $32;
  lightValue[7] := $31;
  lightValue[8] := $a8;
  lightValue[9] := $03;
  lightTcp.Socket.WriteDirect(lightValue);

end;

procedure TLightThread.SendlightRequest;
const
  Convert: array[0..15] of Char = '0123456789ABCDEF';
var
  Buffer: TIdBytes;
  i: Integer;
  recvStr: string;
begin
  if lightTcp.Connected = False then
    lightTcp.Connect;
  lightTcp.Socket.WriteDirect(lightRequest); //꾸준히 입력값 어떤지 물어보기
  lightTcp.Socket.ReadBytes(Buffer, -1, false);
  recvStr := '';
  for I := 0 to Length(Buffer)-1 do begin
    case i of //채널
      5: begin //1번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(1);
        end else begin
          addQue(9);
        end;
      end;
      6: begin //2번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(2);
        end else begin
          addQue(10);
        end;
      end;
      7: begin //3번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(3);
        end else begin
          addQue(11);
        end;
      end;
      8: begin //4번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(4);
        end else begin
          addQue(12);
        end;
      end;
      9: begin //5번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(5);
        end else begin
          addQue(13);
        end;
      end;
      10: begin //6번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(6);
        end else begin
          addQue(14);
        end;
      end;
      11: begin //7번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(7);
        end else begin
          addQue(15);
        end;
      end;
      12: begin //8번
        if Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] = '31' then begin
          addQue(8);
        end else begin
          addQue(16);
        end;
      end;
    end;
    recvStr := recvStr+ Convert[Byte(Buffer[I]) shr 4] + Convert[Byte(Buffer[I]) and $F] + ' ';

  end;
  CodeSite.Send(recvStr);
end;

end.
